name: Terraform — FL Infrastructure

# Triggered manually only. Never runs on push or PR.
on:
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action to run"
        required: true
        default: plan
        type: choice
        options:
          - plan
          - apply
          - destroy

permissions:
  contents: read

env:
  TF_VERSION: "1.7.5"
  WORKING_DIR: terraform
  STATE_BUCKET: fl-demo-terraform-state
  LOCK_TABLE: fl-demo-terraform-locks

jobs:
  # ── Job 1: Bootstrap ────────────────────────────────────────────────────────
  # Creates the S3 state bucket and DynamoDB lock table if they don't exist yet.
  # Safe to re-run: all commands are idempotent.
  bootstrap:
    name: "Bootstrap remote state"
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create S3 state bucket (if missing)
        run: |
          if aws s3api head-bucket --bucket "$STATE_BUCKET" 2>/dev/null; then
            echo "Bucket $STATE_BUCKET already exists — skipping."
          else
            aws s3api create-bucket \
              --bucket "$STATE_BUCKET" \
              --region "${{ secrets.AWS_REGION }}" \
              $( [ "${{ secrets.AWS_REGION }}" != "us-east-1" ] && \
                 echo "--create-bucket-configuration LocationConstraint=${{ secrets.AWS_REGION }}" )
            aws s3api put-bucket-versioning \
              --bucket "$STATE_BUCKET" \
              --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption \
              --bucket "$STATE_BUCKET" \
              --server-side-encryption-configuration \
              '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            echo "Created bucket $STATE_BUCKET."
          fi

      - name: Create DynamoDB lock table (if missing)
        run: |
          if aws dynamodb describe-table --table-name "$LOCK_TABLE" 2>/dev/null; then
            echo "Table $LOCK_TABLE already exists — skipping."
          else
            aws dynamodb create-table \
              --table-name "$LOCK_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region "${{ secrets.AWS_REGION }}"
            echo "Created DynamoDB table $LOCK_TABLE."
          fi

  # ── Job 2: Terraform ────────────────────────────────────────────────────────
  terraform:
    name: "Terraform ${{ github.event.inputs.action }}"
    runs-on: ubuntu-latest
    needs: bootstrap   # always runs after bootstrap succeeds

    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Import existing access entry (if exists)
        if: github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply'
        run: |
          CLUSTER_NAME="fl-demo-cluster"
          CALLER_ARN=$(aws sts get-caller-identity --query Arn --output text)
          echo "Attempting to import access entry for: $CALLER_ARN"
          
          # Import will succeed if not in state, fail if already imported - both are OK
          terraform import \
            'module.eks.aws_eks_access_entry.this["cluster_creator"]' \
            "$CLUSTER_NAME#$CALLER_ARN" 2>&1 | tee import.log
          
          # Check if already imported
          if grep -q "Resource already managed" import.log || grep -q "Successfully imported" import.log; then
            echo "✅ Access entry handled successfully"
            exit 0
          fi
          
          # If import failed for other reason, that's OK - we'll handle in plan
          exit 0

      - name: Terraform Plan
        if: github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply'
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve
