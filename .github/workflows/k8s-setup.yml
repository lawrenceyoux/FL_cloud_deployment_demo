name: K8s — Cluster Setup & Add-ons

# Manually triggered. Run this ONCE after "Terraform — FL Infrastructure" apply succeeds.
# Re-running is safe — all steps are idempotent (kubectl apply, helm upgrade --install).
on:
  workflow_dispatch:
    inputs:
      skip_addons:
        description: "Skip Helm add-ons (namespaces + configmaps only)"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

permissions:
  contents: read

env:
  CLUSTER_NAME: fl-demo-cluster

jobs:
  k8s-setup:
    name: "Configure EKS cluster"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region "${{ secrets.AWS_REGION }}" \
            --name "$CLUSTER_NAME"

      # ── Grant kubectl access ───────────────────────────────────────────────
      # terraform-aws-modules/eks v20 does NOT automatically grant the caller
      # K8s API access unless enable_cluster_creator_admin_permissions = true is
      # set before the cluster is created. For existing clusters we grant access
      # directly via the EKS Access API — both commands are idempotent.
      - name: Grant caller cluster-admin access
        run: |
          CALLER_ARN=$(aws sts get-caller-identity --query Arn --output text)
          echo "Granting cluster-admin to: $CALLER_ARN"

          # Create access entry (no-op if it already exists)
          aws eks create-access-entry \
            --cluster-name "$CLUSTER_NAME" \
            --principal-arn "$CALLER_ARN" \
            --region "${{ secrets.AWS_REGION }}" 2>/dev/null \
            && echo "Access entry created" \
            || echo "Access entry already exists — skipping"

          # Attach the cluster-admin policy
          aws eks associate-access-policy \
            --cluster-name "$CLUSTER_NAME" \
            --principal-arn "$CALLER_ARN" \
            --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy \
            --access-scope type=cluster \
            --region "${{ secrets.AWS_REGION }}" 2>/dev/null \
            && echo "Cluster-admin policy associated" \
            || echo "Policy already associated — skipping"

          # Sanity check: should now return nodes without credential errors
          kubectl get nodes

      # ── Namespaces ────────────────────────────────────────────────────────
      - name: Apply namespaces
        run: kubectl apply -f kubernetes/namespaces/

      # ── ConfigMaps ────────────────────────────────────────────────────────
      - name: Apply ConfigMaps
        run: kubectl apply -f kubernetes/configmaps/

      # ── MLflow Stack (postgres + mlflow-server) ────────────────────────────
      # postgres Secret is embedded in postgres.yaml (stringData).
      # Both StatefulSets are idempotent via kubectl apply.
      - name: Deploy PostgreSQL for MLflow backend
        run: |
          kubectl apply -f kubernetes/deployments/postgres.yaml
          echo "Waiting for postgres to be Ready…"
          kubectl rollout status statefulset/postgres -n mlops --timeout=180s

      - name: Deploy MLflow server
        run: |
          kubectl apply -f kubernetes/deployments/mlflow.yaml
          echo "Waiting for mlflow-server to be Ready…"
          kubectl rollout status statefulset/mlflow-server -n mlops --timeout=300s

      - name: Verify MLflow endpoint
        run: |
          echo "MLflow service:"
          kubectl get svc mlflow-server -n mlops
          echo ""
          echo "To access locally:  kubectl port-forward -n mlops svc/mlflow-server 5000:5000"
          echo "Cluster-internal:   http://mlflow-server.mlops:5000"

      # ── Metrics Server ────────────────────────────────────────────────────
      # Lightweight; required for kubectl top nodes/pods and HPA.
      - name: Install Metrics Server
        if: github.event.inputs.skip_addons == 'false'
        run: |
          kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
          kubectl rollout status deployment/metrics-server -n kube-system --timeout=120s

      # ── Cluster Autoscaler ────────────────────────────────────────────────
      # Scales node groups within the min/max bounds declared in Terraform.
      - name: Install Cluster Autoscaler
        if: github.event.inputs.skip_addons == 'false'
        run: |
          helm repo add autoscaler https://kubernetes.github.io/autoscaler
          helm repo update
          helm upgrade --install cluster-autoscaler autoscaler/cluster-autoscaler \
            --namespace kube-system \
            --set autoDiscovery.clusterName="$CLUSTER_NAME" \
            --set awsRegion="${{ secrets.AWS_REGION }}" \
            --set rbac.serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="" \
            --wait --timeout 120s

      # ── AWS Load Balancer Controller ──────────────────────────────────────
      # Required to expose services via AWS ALB Ingress.
      - name: Install AWS Load Balancer Controller
        if: github.event.inputs.skip_addons == 'false'
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            --namespace kube-system \
            --set clusterName="$CLUSTER_NAME" \
            --set serviceAccount.create=true \
            --set serviceAccount.name=aws-load-balancer-controller \
            --wait --timeout 120s

      # ── Summary ───────────────────────────────────────────────────────────
      - name: Show cluster state
        run: |
          echo "=== Nodes ==="
          kubectl get nodes
          echo "=== Namespaces ==="
          kubectl get namespaces
          echo "=== ConfigMaps (federated-learning) ==="
          kubectl get configmaps -n federated-learning
          echo "=== MLflow stack (mlops) ==="
          kubectl get statefulsets,pods,svc -n mlops
          echo "=== kube-system deployments ==="
          kubectl get deployments -n kube-system
